# -*- coding: utf-8 -*-
"""19BCP091_ML_Lab_Assignment_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eVh5DscjhEFjVtrCdFTx7SQHpui2bStl

# **MACHINE LEARNING LAB - 1**

# **Problem Statement : Python Practic Assignmentt**

**Q1. Write a function that converts a decimal number to binary number.**
"""

def decimalToBinary(n):
    return bin(n).replace("0b", "")

def decimalToBinary_2(n):
    ans = ''
    while n > 1:
        ans = str(n % 2) + ans
        n = n // 2
    return str(n) + ans

decimalToBinary_2(8)

decimalToBinary_2(255)

"""**Q2. Write a function to compute the sigmoid of a vector of values. <br> 
A sigmoid of a real number $x$ is defind as $\sigma(x)$ = $\frac{1}{1+e^-x}$ <br>
For example:
Input: $[x_{1}, x_{2}, x_{3}, x_{4}]$ <br>
Output: $[\sigma{(x_{1})}, \sigma{(x_{2})}, \sigma{(x_{3})}, \sigma{(x_{4})}]$**
"""

import numpy as np
def sigmoid(x):
    return 1 / (1 + np.exp(-x))

sigmoid(np.array([1, 2, 3, 4]))

"""**Q3. Write a function to compute the derivative of the sigmoid function with respect to its input $x$. Here, the $x$ is a vector. <br> 
The derivative of a sigmoid is defined as: $\sigma(x)(1 - \sigma(x))$
<br>**
"""

def sigmoid_derivative(x):
    return sigmoid(x) * (1 - sigmoid(x))

sigmoid_derivative(np.array([1, 2, 3, 4]))

"""**Q4. Write a function to normalize the rows of a matrix. After applying this function to an input matrix $x$ of size $m \times n$, each row of $x$ should be a vector of unit length.**"""

def normalize(x):
    b = np.linalg.norm(x, axis=1)
    return np.divide(x.T, b).T


normalize(np.array([[1, 2, 3], [4, 5, 6]]))

"""**Q5. Write a program which can map() and filter() to make a list whose elements are cube of even numbers in a list.**"""

def even_cube(x):
    y = filter(lambda x: x%2==0, x)
    z = map(lambda x: x**3, y)
    return np.array(list(z))

even_cube(np.array([1,2,3,4,5,6,7]))

"""
**Q6. consider the marks list of class students given two lists <br>
Students = ['student1','student2','student3','student4','student5','student6','student7','student8','student9','student10'] <br>
Marks = [45, 78, 12, 14, 48, 43, 45, 98, 35, 80] <br>
from the above two lists the Student[0] got Marks[0],  Student[1] got Marks[1] and so on <br><br>
your task is to print the name of students <br>
<strong>a. Who got top 5 ranks, in the descending order of marks</strong> <br>
<strong>b. Who got least 5 ranks, in the increasing order of marks</strong><br>
<strong>d. Who got marks between  &gt;25th percentile &lt;75th percentile, in the increasing order of marks</strong>**

<pre>
Ex 1: 
Students=['student1','student2','student3','student4','student5','student6','student7','student8','student9','student10'] 
Marks = [45, 78, 12, 14, 48, 43, 47, 98, 35, 80]
a. 
student8  98
student10 80
student2  78
student5  48
student7  47
b.
student3 12
student4 14
student9 35
student6 43
student1 45
c.
student9 35
student6 43
student1 45
student7 47
student5 48
</pre>"""

Students = np.array(['student1','student2','student3','student4','student5','student6','student7','student8','student9','student10'])
a = np.array([45, 78, 12, 14, 48, 43, 45, 98, 35, 80])
b = np.argsort(a)
b = b[::-1]
print(b)
print(Students[b[:5]])
print(a[b[:5]])

b = b[::-1]
print(b)
print(Students[b[:5]])
print(a[b[:5]])

start = len(Students)//2//2
stop = len(Students)//2 + start
print(Students[b[start:stop]])
print(a[b[start:stop]])

"""**Q7. consider you have given n data points in the form of list of tuples like S=[(x1,y1),(x2,y2),(x3,y3),(x4,y4),(x5,y5),..,(xn,yn)] and a point P=(p,q) <br> your task is to find 5 closest points(based on cosine distance) in S from P**
<brs (x,y) and (p,q) is defind as $cos^{-1}(\frac{(x\cdot p+y\cdot q)}{\sqrt(x^2+y^2)\cdot\sqrt(p^2+q^2)})$>cosine distance between two point
<pre>
Ex:

S= [(1,2),(3,4),(-1,1),(6,-7),(0, 6),(-5,-8),(-1,-1)(6,0),(1,-1)]
P= (3,-4)

Output:
(6,-7)
(1,-1)
(6,0)
(-5,-8)
(-1,-1)
</pre>
"""

def cosine_dist(x, p):
    return np.arccos(np.divide((x[0]*p[0]+x[1]*p[1]), np.sqrt(x[0]**2+x[1]**2)*np.sqrt(p[0]**2+p[1]**2)))

cosine_dist((1,2), (3, -4))

def cosine_dist(x, y, p, q):
    return np.arccos(np.divide((x*p+y*q), np.sqrt(x**2+y**2)*np.sqrt(p**2+q**2)))

x = np.array([1,3,-1,6,0,-5,-1,6,1])
y = np.array([2,4,1,-7,6,-8,-1,0,-1])
p, q = 3, -4

dist = cosine_dist(x, y, p, q)
dist_arg = dist.argsort()

x[dist_arg[:5]]
y[dist_arg[:5]]
z = map(lambda a, b: (a, b), x[dist_arg[:5]], y[dist_arg[:5]])
list(z)

"""**Q8: Given two sentences S1, S2
You will be given a list of lists, each sublist will be of length 2 i.e. [[x,y],[p,q],[l,m]..[r,s]]
consider its like a matrix of n rows and two columns**

a. **the first column Y will contain interger values** <br>
b. **the second column $Y_{score}$ will be having float values**<br>
**Your task is to find the value of $f(Y,Y_{score}) = -1*\frac{1}{n}\Sigma_{for each Y,Y_{score} pair}(Ylog10(Y_{score})+(1-Y)log10(1-Y_{score}))$ here n is the number of rows in the matrix**
<pre>
Ex:
[[1, 0.4], [0, 0.5], [0, 0.9], [0, 0.3], [0, 0.6], [1, 0.1], [1, 0.9], [1, 0.8]]
output:
0.4243099
</pre>
$\frac{-1}{8}\cdot((1\cdot log_{10}(0.4)+0\cdot log_{10}(0.6))+(0\cdot log_{10}(0.5)+1\cdot log_{10}(0.5)) + ... + (1\cdot log_{10}(0.8)+0\cdot log_{10}(0.2)) )$
"""

def func3(x, y):
    z = map(lambda a, b: a*np.log10(b)+(1-a)*np.log10(1-b), x, y)
    z = np.array(list(z))

    return z.sum()/len(x)*-1

a = np.array([1,0,0,0,0,1,1,1])
b = np.array([0.4, 0.5, 0.9, 0.3, 0.6, 0.1, 0.9, 0.8])
func3(a, b)